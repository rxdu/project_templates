/*
******************************************************************************
File:     startup.s
Info:     Generated by Atollic TrueSTUDIO(R) 8.1.0   2018-04-23

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/**
**===========================================================================
**  Definitions
**===========================================================================
*/
/* Stack Sizes */
.set  UND_STACK_SIZE, 0x00000004  /* 4 byte "undefined instruction" interrupt stack */
.set  ABT_STACK_SIZE, 0x00000004  /* 4 byte "abort" interrupt stack */
.set  FIQ_STACK_SIZE, 0x00000004  /* 4 byte "FIQ" interrupt stack */
.set  IRQ_STACK_SIZE, 0X00000004  /* 4 byte "IRQ" normal interrupt stack */
.set  SVC_STACK_SIZE, 0x00000004  /* 4 byte "SVC" supervisor mode stack */
/* Note! stack for "USER" mode will grow after the "SVC" supervisor mode stack */

/* Standard definitions of Mode bits and Interrupt (I & F) flags in PSRs (program status registers) */
.set  MODE_USR, 0x10         /* Normal User Mode */
.set  MODE_FIQ, 0x11         /* Fast Interrupts Mode */
.set  MODE_IRQ, 0x12         /* Standard Interrupts Mode */
.set  MODE_SVC, 0x13         /* Supervisor Mode, protected mode for operating system */
.set  MODE_ABT, 0x17         /* Abort Processing Memory Faults Mode */
.set  MODE_UND, 0x1B         /* Undefined Instructions Mode */
.set  MODE_SYS, 0x1F         /* System Mode, privileged user mode for operating System */

.set  I_BIT, 0x80            /* when I bit is set, IRQ is disabled (program status registers) */
.set  F_BIT, 0x40            /* when F bit is set, FIQ is disabled (program status registers) */

.text
.arm

.global Reset_Handler
.global _vectors
.global _startup
.func   _startup

_startup:

/**
**===========================================================================
**  Reset, Exception, and Interrupt vectors
**===========================================================================
*/
  .section .isr_vector,"a",%progbits
  .type _vectors, %object
  .size _vectors, .-_vectors

/* Configure Exception vectors */
_vectors:       ldr     PC, ResetAddress    /* Reset */
                ldr     PC, UndefAddress    /* Undefined instruction execution */
                ldr     PC, SWIAddress      /* Software interrupt (SWI) instruction */
                ldr     PC, PAbortAddress   /* Pre-fetch Abort interrupt */
                ldr     PC, DAbortAddress   /* Data Abort interrupt */
                nop                         /* Reserved Vector */
                ldr     PC, IRQAddress      /* Normal interrupt */
                ldr     PC, FIQAddress      /* High-speed interrupt */

ResetAddress:   .word   Reset_Handler       /* defined below in this module */
UndefAddress:   .word   Undefined_Handler   /* defined in main.c  */
SWIAddress:     .word   SWI_Handler         /* defined in main.c  */
PAbortAddress:  .word   PAbort_Handler      /* defined in main.c  */
DAbortAddress:  .word   DAbort_Handler      /* defined in main.c  */
IRQAddress:     .word   IRQ_Handler         /* defined in main.c  */
FIQAddress:     .word   FIQ_Handler         /* defined in main.c  */
                .word   0                   /* Totally 64 bytes used */



/**
**===========================================================================
**  Program
**===========================================================================
*/

/**
**===========================================================================
**
**  Abstract: Reset interrupt
**    1. Setup a stack for each mode
**       For each mode IRQ/FIQ interrupts are initially disabled
**         Note! a usable stack is only setup for for User mode
**    2. Call system initialzation routine
**    3. Copy .data section from ROM to RAM
**    4. Clear .bss section (Zero init)
**    5. Enter main
**
**===========================================================================
*/
  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function

Reset_Handler:

  /* 1. Setup a stack for each mode */
  ldr    r0, =_estack
  msr    CPSR_c, #MODE_UND|I_BIT|F_BIT  /* Undefined Instruction Mode  */
  mov    sp, r0
  sub    r0, r0, #UND_STACK_SIZE
  msr    CPSR_c, #MODE_ABT|I_BIT|F_BIT  /* Abort Mode */
  mov    sp, r0
  sub    r0, r0, #ABT_STACK_SIZE
  msr    CPSR_c, #MODE_FIQ|I_BIT|F_BIT  /* FIQ Mode */
  mov    sp, r0
  sub    r0, r0, #FIQ_STACK_SIZE
  msr    CPSR_c, #MODE_IRQ|I_BIT|F_BIT  /* IRQ Mode */
  mov    sp, r0
  sub    r0, r0, #IRQ_STACK_SIZE
  msr    CPSR_c, #MODE_SVC|I_BIT|F_BIT  /* Supervisor Mode */
  mov    sp, r0
  sub    r0, r0, #SVC_STACK_SIZE
  msr    CPSR_c, #MODE_SYS|I_BIT|F_BIT  /* User Mode */
  mov    sp, r0

  /* 2. Call system initialzation routine */
  LDR    r12,=SystemInit
  MOV    lr,pc            /* set the return address */
  BX     r12

  /* 3. copy .data section (Copy from ROM to RAM) */
  ldr    R1, =_sidata
  ldr    R2, =_sdata
  ldr    R3, =_edata

copy:
  cmp    R2, R3
  ldrlo  R0, [R1], #4
  strlo  R0, [R2], #4
  blo    copy


  /* 4. Clear .bss section (Zero init) */
  mov    R0, #0
  ldr    R1, =_sbss
  ldr    R2, =_ebss

clear:
  cmp    R1, R2
  strlo  R0, [R1], #4
  blo    clear

  /* 5. Run static constructors  */
  LDR    r12,=__libc_init_array
  MOV    lr,pc           /* set the return address */
  BX     r12

  /* 6. Enter main  */
  LDR    r12,=main
  MOV    lr,pc           /* set the return address */
  BX     r12

forever:
  b      forever         /* return from main, do nothing */

.endfunc
.end
